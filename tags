!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
$(BINDIR)	Makefile	/^$(BINDIR):$/;"	t
$(OBJDIR)	Makefile	/^$(OBJDIR):$/;"	t
$(OBJDIR)/%.o	Makefile	/^$(OBJECTS): $(OBJDIR)\/%.o : $(SRCDIR)\/%.cpp $(HEADERS) | $(OBJDIR)$/;"	t
$(OBJECTS)	Makefile	/^$(OBJECTS): $(OBJDIR)\/%.o : $(SRCDIR)\/%.cpp $(HEADERS) | $(OBJDIR)$/;"	t
Autores	README.md	/^## Autores$/;"	s
BBoundAlgorithm	include/branchBound.h	/^        BBoundAlgorithm(int n, int m, edgeListType &edges, int **costs){$/;"	f	class:BBoundAlgorithm
BBoundAlgorithm	include/branchBound.h	/^class BBoundAlgorithm{$/;"	c
BINDIR	Makefile	/^BINDIR = .\/bin$/;"	m
BacktrackAlgorithm	include/backtrack.h	/^        BacktrackAlgorithm(int n, int m, std::vector<std::pair<int,int>> &edges, int **costs){$/;"	f	class:BacktrackAlgorithm
BacktrackAlgorithm	include/backtrack.h	/^class BacktrackAlgorithm{$/;"	c
C	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
CC	Makefile	/^CC = g++$/;"	m
CLOSEP	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
COMMA	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
ConstructiveHeuristic	include/constructiveHeuristic.h	/^    ConstructiveHeuristic(){}$/;"	f	class:ConstructiveHeuristic
ConstructiveHeuristic	include/constructiveHeuristic.h	/^class ConstructiveHeuristic{$/;"	c
DATADIR	Makefile	/^DATADIR = .\/data$/;"	m
DONEF	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
DONEL	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
DestructiveHeuristic	include/destructiveHeuristic.h	/^    DestructiveHeuristic(){}$/;"	f	class:DestructiveHeuristic
DestructiveHeuristic	include/destructiveHeuristic.h	/^class DestructiveHeuristic{$/;"	c
EDGES	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
ERRORF	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
ERRORL	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
Edge	include/edge.h	/^    Edge(int _u, int _v, int _lc, std::vector<int> &_qc):$/;"	f	class:Edge
Edge	include/edge.h	/^class Edge{$/;"	c
Edges	README.md	/^# Edges$/;"	c
Execução do algoritmo	README.md	/^## Execução do algoritmo$/;"	s
FINAL	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
FileStates	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	g	class:Parser
Forest	include/forest.h	/^class Forest{$/;"	c
HEADERS	Makefile	/^HEADERS := $(wildcard $(INCDIR)\/*)$/;"	m
INCDIR	Makefile	/^INCDIR = .\/include$/;"	m
INF	include/defines.h	/^#define INF /;"	d
LPLowerBound	include/LPLowerBound.h	/^        LPLowerBound(int _n, int _m, numType *_piParameters, numType *_fCosts, \\$/;"	f	class:LPLowerBound
LPLowerBound	include/LPLowerBound.h	/^class LPLowerBound{$/;"	c
ListStates	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	g	class:Parser
M	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
N	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
NBITS	include/defines.h	/^#define NBITS /;"	d
NUM	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
NUMBERS	include/fileParser.h	/^        const std::string NUMBERS = "0123456789";$/;"	m	class:Parser	typeref:typename:const std::string
OBJDIR	Makefile	/^OBJDIR = .\/obj$/;"	m
OBJECTS	Makefile	/^OBJECTS := $(SOURCES:$(SRCDIR)\/%.cpp=$(OBJDIR)\/%.o)$/;"	m
OPENP	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
PBLowerBound	include/PBLowerBound.h	/^        PBLowerBound(int _n, int _m){$/;"	f	class:PBLowerBound
PBLowerBound	include/PBLowerBound.h	/^class PBLowerBound{$/;"	c
PROJ_NAME	Makefile	/^PROJ_NAME = agmq$/;"	m
PTAG	src/main.cpp	/^#define PTAG /;"	d	file:
Parser	include/fileParser.h	/^        Parser(std::string _fileName){$/;"	f	class:Parser
Parser	include/fileParser.h	/^class Parser{$/;"	c
PathRelinking	include/pathRelinking.h	/^class PathRelinking {$/;"	c
Q1	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
Q2	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
QMST Problem - NP Hard Project	README.md	/^# QMST Problem - NP Hard Project$/;"	c
RM	Makefile	/^RM = -rm$/;"	m
RandomPoll	include/RandomPoll.h	/^    RandomPoll(vector<double> v, double sf){probs = v; skewFactor = sf;}$/;"	f	class:RandomPoll
RandomPoll	include/RandomPoll.h	/^class RandomPoll{$/;"	c
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SOURCES	Makefile	/^SOURCES := $(wildcard $(SRCDIR)\/*.cpp)$/;"	m
SRCDIR	Makefile	/^SRCDIR = .\/src$/;"	m
SolutionsPoller	include/SolutionsPoller.h	/^class SolutionsPoller{$/;"	c
SolutionsPooler	include/SolutionsPoller.h	/^        SolutionsPooler(int _maxSize, double _skewValue): maxSize(_maxSize), skewValue(_skewValu/;"	f	class:SolutionsPoller
State	include/branchBound.h	/^    State(int ne, int c, maskType v, maskType chos, int ac){$/;"	f	struct:State
State	include/branchBound.h	/^struct State{$/;"	s
TabuSearch	include/tabuSearch.h	/^    TabuSearch(){$/;"	f	class:TabuSearch
TabuSearch	include/tabuSearch.h	/^class TabuSearch{$/;"	c
Tree	include/pathRelinking.h	/^} Tree;$/;"	t	typeref:struct:Tree_s
Tree_s	include/pathRelinking.h	/^typedef struct Tree_s {$/;"	s
UnionFind	include/unionFind.h	/^        UnionFind(int n){$/;"	f	class:UnionFind
UnionFind	include/unionFind.h	/^class UnionFind{$/;"	c
UnionFindNRB	include/unionFind.h	/^        UnionFindNRB(int n){$/;"	f	class:UnionFindNRB
UnionFindNRB	include/unionFind.h	/^class UnionFindNRB{$/;"	c
Vertice	include/pathRelinking.h	/^typedef int Vertice;$/;"	t	typeref:typename:int
_ARG_PARSER_H_	include/argParser.h	/^#define _ARG_PARSER_H_$/;"	d
_BACKTRACK_H_	include/backtrack.h	/^#define _BACKTRACK_H_$/;"	d
_BBOUND_H_	include/branchBound.h	/^#define _BBOUND_H_$/;"	d
_CONSTRUCTIVE_H_	include/constructiveHeuristic.h	/^#define _CONSTRUCTIVE_H_$/;"	d
_DESTRUCTIVE_H_	include/destructiveHeuristic.h	/^#define _DESTRUCTIVE_H_$/;"	d
_EDGE_H_	include/edge.h	/^#define _EDGE_H_$/;"	d
_FILE_PARSER_H_	include/fileParser.h	/^#define _FILE_PARSER_H_$/;"	d
_FOREST_H_	include/forest.h	/^#define _FOREST_H_$/;"	d
_HELP_FN_H_	include/helpFn.h	/^#define _HELP_FN_H_$/;"	d
_PATH_RELINLING_H	include/pathRelinking.h	/^#define _PATH_RELINLING_H$/;"	d
_PB_LOWER_BOUND_H_	include/PBLowerBound.h	/^#define _PB_LOWER_BOUND_H_$/;"	d
_POOLER_H_	include/SolutionsPoller.h	/^#define _POOLER_H_$/;"	d
_UNION_FIND_H_	include/unionFind.h	/^#define _UNION_FIND_H_$/;"	d
_backtrack	include/backtrack.h	/^        int _backtrack(int i, int cost){$/;"	f	class:BacktrackAlgorithm	typeref:typename:int
_bbound	include/branchBound.h	/^        int _bbound(){$/;"	f	class:BBoundAlgorithm	typeref:typename:int
_costs	include/backtrack.h	/^        int **_costs;                           \/\/!< Matriz de custos$/;"	m	class:BacktrackAlgorithm	typeref:typename:int **
_costs	include/branchBound.h	/^        int **_costs; \/\/ matriz de custos$/;"	m	class:BBoundAlgorithm	typeref:typename:int **
_defines_h_	include/defines.h	/^#define _defines_h_$/;"	d
_edges	include/backtrack.h	/^        std::vector<std::pair<int,int>> _edges; \/\/!< Lista com todas as arestas$/;"	m	class:BacktrackAlgorithm	typeref:typename:std::vector<std::pair<int,int>>
_edges	include/branchBound.h	/^        edgeListType _edges; \/\/ lista com todas as arestas$/;"	m	class:BBoundAlgorithm	typeref:typename:edgeListType
_getPath	include/pathRelinking.h	/^        std::list<Edge> _getPath(Vertice actual, Vertice destiny, std::vector<bool> &visited) {$/;"	f	class:PathRelinking	typeref:typename:std::list<Edge>
_m	include/backtrack.h	/^        int _m, _n;                             \/\/!< Qntd de arestas e de nós$/;"	m	class:BacktrackAlgorithm	typeref:typename:int
_m	include/branchBound.h	/^        int _m, _n; \/\/ qntd de arestas e de nos$/;"	m	class:BBoundAlgorithm	typeref:typename:int
_n	include/backtrack.h	/^        int _m, _n;                             \/\/!< Qntd de arestas e de nós$/;"	m	class:BacktrackAlgorithm	typeref:typename:int
_n	include/branchBound.h	/^        int _m, _n; \/\/ qntd de arestas e de nos$/;"	m	class:BBoundAlgorithm	typeref:typename:int
_n	include/unionFind.h	/^        int _n;$/;"	m	class:UnionFind	typeref:typename:int
_n	include/unionFind.h	/^        int _n;$/;"	m	class:UnionFindNRB	typeref:typename:int
addEdge	include/forest.h	/^        void addEdge(int i){$/;"	f	class:Forest	typeref:typename:void
addSolution	include/SolutionsPoller.h	/^        void addSolution(Forest &solution){$/;"	f	class:SolutionsPoller	typeref:typename:void
all	Makefile	/^all: project$/;"	t
allocateCosts	include/fileParser.h	/^        void allocateCosts(){$/;"	f	class:Parser	typeref:typename:void
alreadyChosen	include/branchBound.h	/^    int nextEdge, cost, alreadyChosen;$/;"	m	struct:State	typeref:typename:int
argument_type	include/fileParser.h	/^        typedef pair<int,int> argument_type;$/;"	t	struct:std::hash	typeref:typename:pair<int,int>
avaibleEdges	include/forest.h	/^        static vector<Edge> avaibleEdges;$/;"	m	class:Forest	typeref:typename:vector<Edge>
backtrack	include/backtrack.h	/^        int backtrack(){$/;"	f	class:BacktrackAlgorithm	typeref:typename:int
bbound	include/branchBound.h	/^        int bbound(){$/;"	f	class:BBoundAlgorithm	typeref:typename:int
build	include/constructiveHeuristic.h	/^    void build(Forest &forest, UnionFind &uf){$/;"	f	class:ConstructiveHeuristic	typeref:typename:void
c	README.md	/^# c$/;"	c
chosen	include/branchBound.h	/^    maskType visited, chosen;$/;"	m	struct:State	typeref:typename:maskType
clean	Makefile	/^clean: clean_proj$/;"	t
clean_proj	Makefile	/^clean_proj:$/;"	t
cmp	include/PBLowerBound.h	/^bool cmp(std::pair<numType,int> &a, std::pair<numType,int> &b){$/;"	f	typeref:typename:bool
computeLB	include/branchBound.h	/^    void computeLB(int n, int m, edgeListType &edges, int **costs, numType *piParameters, \\$/;"	f	struct:State	typeref:typename:void
construct	include/constructiveHeuristic.h	/^    void construct(Forest &forest, vector<Edge> &edges){$/;"	f	class:ConstructiveHeuristic	typeref:typename:void
constructiveHeuristic	include/tabuSearch.h	/^    ConstructiveHeuristic constructiveHeuristic;$/;"	m	class:TabuSearch	typeref:typename:ConstructiveHeuristic
cost	include/branchBound.h	/^    int nextEdge, cost, alreadyChosen;$/;"	m	struct:State	typeref:typename:int
cost	include/forest.h	/^        int cost;$/;"	m	class:Forest	typeref:typename:int
cost	include/pathRelinking.h	/^    int cost; \/\/ stub$/;"	m	struct:Tree_s	typeref:typename:int
costs	include/fileParser.h	/^        int **costs;$/;"	m	class:Parser	typeref:typename:int **
costs	include/forest.h	/^        vector<int> costs; \/\/ vetor d$/;"	m	class:Forest	typeref:typename:vector<int>
counter	include/backtrack.h	/^        long int counter = 0;$/;"	m	class:BacktrackAlgorithm	typeref:typename:long int
counter	include/branchBound.h	/^        long int counter = 0;$/;"	m	class:BBoundAlgorithm	typeref:typename:long int
currentRoot	include/forest.h	/^        int currentRoot;$/;"	m	class:Forest	typeref:typename:int
debug	src/main.cpp	/^#define debug /;"	d	file:
delta	include/LPLowerBound.h	/^        numType delta;$/;"	m	class:LPLowerBound	typeref:typename:numType
desctruct	include/destructiveHeuristic.h	/^    void desctruct(Forest &forest, int numRemovals){$/;"	f	class:DestructiveHeuristic	typeref:typename:void
destructiveHeuristic	include/tabuSearch.h	/^    DestructiveHeuristic destructiveHeuristic;$/;"	m	class:TabuSearch	typeref:typename:DestructiveHeuristic
done	include/backtrack.h	/^        bool done = false;$/;"	m	class:BacktrackAlgorithm	typeref:typename:bool
edgeID	include/fileParser.h	/^        std::unordered_map<std::pair<int,int>, int> edgeID;$/;"	m	class:Parser	typeref:typename:std::unordered_map<std::pair<int,int>,int>
edgeList	include/forest.h	/^        vector<int> edgeList;$/;"	m	class:Forest	typeref:typename:vector<int>
edgeListType	include/LPLowerBound.h	/^#define edgeListType /;"	d
edgeListType	include/PBLowerBound.h	/^#define edgeListType /;"	d
edgeListType	include/branchBound.h	/^#define edgeListType /;"	d
edges	include/fileParser.h	/^        std::vector<std::pair<int,int>> edges;$/;"	m	class:Parser	typeref:typename:std::vector<std::pair<int,int>>
edges	include/pathRelinking.h	/^    Edge edges;$/;"	m	struct:Tree_s	typeref:typename:Edge
eof	README.md	/^# eof$/;"	c
error	include/helpFn.h	/^std::string error(std::string errorName, std::string helpText = "") {$/;"	f	typeref:typename:std::string
fCosts	include/LPLowerBound.h	/^        numType *fCosts;$/;"	m	class:LPLowerBound	typeref:typename:numType *
fCosts	include/branchBound.h	/^        numType *fCosts;$/;"	m	class:BBoundAlgorithm	typeref:typename:numType *
f_i	include/PBLowerBound.h	/^        numType f_i(edgeListType &edges,  maskType visited, maskType chosen, \\$/;"	f	class:PBLowerBound	typeref:typename:numType
fileName	include/fileParser.h	/^        std::string fileName;$/;"	m	class:Parser	typeref:typename:std::string
find	include/unionFind.h	/^        int find(int current){$/;"	f	class:UnionFind	typeref:typename:int
find	include/unionFind.h	/^        int find(int current){$/;"	f	class:UnionFindNRB	typeref:typename:int
forestSet	include/SolutionsPoller.h	/^        set<Forest> forestSet;$/;"	m	class:SolutionsPoller	typeref:typename:set<Forest>
getCosts	include/fileParser.h	/^        int** getCosts(){ return costs; }$/;"	f	class:Parser	typeref:typename:int **
getEdges	include/fileParser.h	/^        std::vector<std::pair<int,int>> getEdges(){ return edges; }$/;"	f	class:Parser	typeref:typename:std::vector<std::pair<int,int>>
getM	include/fileParser.h	/^        int getM(){ return m; }$/;"	f	class:Parser	typeref:typename:int
getN	include/fileParser.h	/^        int getN(){ return n; }$/;"	f	class:Parser	typeref:typename:int
getNeighbourhood	include/forest.h	/^        void getNeighbourhood(vector<pair<int,int>> &neighbourhood, vector<int> &neighbourhoodCo/;"	f	class:Forest	typeref:typename:void
getPath	include/pathRelinking.h	/^        std::list<Edge> getPath(Vertice source, Vertice destiny) {$/;"	f	class:PathRelinking	typeref:typename:std::list<Edge>
getSimmetryDifferenceEdges	include/pathRelinking.h	/^        std::list<Edge> getSimmetryDifferenceEdges(Tree origin, Tree destiny) {$/;"	f	class:PathRelinking	typeref:typename:std::list<Edge>
getSolution	include/SolutionsPoller.h	/^        Forest getSolution(){$/;"	f	class:SolutionsPoller	typeref:typename:Forest
goToNeighbour	include/forest.h	/^        void goToNeighbour(pair<int,int> n){$/;"	f	class:Forest	typeref:typename:void
hash	include/fileParser.h	/^    template<> struct hash<pair<int,int>>$/;"	s	namespace:std
initRootedTree	include/forest.h	/^        void initRootedTree(int x){$/;"	f	class:Forest	typeref:typename:void
intoProb	include/RandomPoll.h	/^    void intoProb(){$/;"	f	class:RandomPoll	typeref:typename:void
iterator	include/SolutionsPoller.h	/^    typedef iterType set<Forest>::iterator;$/;"	t	class:SolutionsPoller	typeref:typename:iterType set<Forest>::
join	include/unionFind.h	/^        void join(int a, int b){$/;"	f	class:UnionFind	typeref:typename:void
join	include/unionFind.h	/^        void join(int a, int b){$/;"	f	class:UnionFindNRB	typeref:typename:void
kruskal	include/PBLowerBound.h	/^        int kruskal(kruskalListType &kruskalList, edgeListType &edges, \\$/;"	f	class:PBLowerBound	typeref:typename:int
kruskalListType	include/PBLowerBound.h	/^#define kruskalListType /;"	d
levelingProcedure	include/LPLowerBound.h	/^        numType levelingProcedure(edgeListType edges, maskType &visited, maskType &chosen, \\$/;"	f	class:LPLowerBound	typeref:typename:numType
limit	include/tabuSearch.h	/^    int limit;$/;"	m	class:TabuSearch	typeref:typename:int
linearCost	include/edge.h	/^    int linearCost; \/\/ linear cost of the edge$/;"	m	class:Edge	typeref:typename:int
lowerBound	include/branchBound.h	/^    numType lowerBound;$/;"	m	struct:State	typeref:typename:numType
m	README.md	/^# m$/;"	c
m	include/LPLowerBound.h	/^        int n, m;$/;"	m	class:LPLowerBound	typeref:typename:int
m	include/PBLowerBound.h	/^        int n, m;$/;"	m	class:PBLowerBound	typeref:typename:int
m	include/fileParser.h	/^        int n, m;$/;"	m	class:Parser	typeref:typename:int
main	src/main.cpp	/^int main(int argc, char **argv){$/;"	f	typeref:typename:int
maskType	include/LPLowerBound.h	/^#define maskType /;"	d
maskType	include/PBLowerBound.h	/^#define maskType /;"	d
maskType	include/branchBound.h	/^#define maskType /;"	d
maxSize	include/SolutionsPoller.h	/^        int maxSize;$/;"	m	class:SolutionsPoller	typeref:typename:int
n	README.md	/^# n$/;"	c
n	include/LPLowerBound.h	/^        int n, m;$/;"	m	class:LPLowerBound	typeref:typename:int
n	include/PBLowerBound.h	/^        int n, m;$/;"	m	class:PBLowerBound	typeref:typename:int
n	include/fileParser.h	/^        int n, m;$/;"	m	class:Parser	typeref:typename:int
nextEdge	include/branchBound.h	/^    int nextEdge, cost, alreadyChosen;$/;"	m	struct:State	typeref:typename:int
noUpdtCount	include/tabuSearch.h	/^    int noUpdtCount;$/;"	m	class:TabuSearch	typeref:typename:int
numNodes	include/forest.h	/^        int numNodes;$/;"	m	class:Forest	typeref:typename:int
numType	include/LPLowerBound.h	/^#define numType /;"	d
numType	include/PBLowerBound.h	/^#define numType /;"	d
numType	include/branchBound.h	/^#define numType /;"	d
operator ()	include/fileParser.h	/^        result_type operator()(argument_type const& s) const noexcept$/;"	f	struct:std::hash	typeref:typename:result_type
operator <	include/branchBound.h	/^bool operator <(const State & a, const State & b){$/;"	f	typeref:typename:bool
operator <	include/edge.h	/^    bool operator<(const Edge& e) const {$/;"	f	class:Edge	typeref:typename:bool
operator ==	include/edge.h	/^    bool operator==(const Edge& e) const {$/;"	f	class:Edge	typeref:typename:bool
originalTree	include/pathRelinking.h	/^        Tree originalTree; $/;"	m	class:PathRelinking	typeref:typename:Tree
parents	include/unionFind.h	/^        int *parents;$/;"	m	class:UnionFind	typeref:typename:int *
parents	include/unionFind.h	/^        int *parents;$/;"	m	class:UnionFindNRB	typeref:typename:int *
parse	include/fileParser.h	/^        bool parse(){$/;"	f	class:Parser	typeref:typename:bool
parseFilename	include/argParser.h	/^std::string parseFilename(int argc, char **argv) {$/;"	f	typeref:typename:std::string
parseList	include/fileParser.h	/^        bool parseList(std::string s, std::string dels, int numberElements, int *array){$/;"	f	class:Parser	typeref:typename:bool
parseParam	include/argParser.h	/^std::pair<std::string, std::string> parseParam(std::string rawParam) {$/;"	f	typeref:typename:std::pair<std::string,std::string>
pb	include/PBLowerBound.h	/^        numType pb(edgeListType edges,  maskType &visited,  maskType &chosen, \\$/;"	f	class:PBLowerBound	typeref:typename:numType
pblb	include/LPLowerBound.h	/^        PBLowerBound* pblb;$/;"	m	class:LPLowerBound	typeref:typename:PBLowerBound *
pblb	include/branchBound.h	/^        PBLowerBound* pblb;$/;"	m	class:BBoundAlgorithm	typeref:typename:PBLowerBound *
piParameters	include/LPLowerBound.h	/^        numType *piParameters;$/;"	m	class:LPLowerBound	typeref:typename:numType *
piParameters	include/branchBound.h	/^        numType *piParameters;$/;"	m	class:BBoundAlgorithm	typeref:typename:numType *
placed	include/backtrack.h	/^        std::vector<int> placed;                \/\/!< Arestas do backtrack$/;"	m	class:BacktrackAlgorithm	typeref:typename:std::vector<int>
poll	include/RandomPoll.h	/^    int poll(){$/;"	f	class:RandomPoll	typeref:typename:int
prepareProbs	include/RandomPoll.h	/^    void prepareProbs(){$/;"	f	class:RandomPoll	typeref:typename:void
prepareUFind	include/branchBound.h	/^        void prepareUFind(State & state, UnionFindNRB *ufind){$/;"	f	class:BBoundAlgorithm	typeref:typename:void
probs	include/RandomPoll.h	/^    vector<double> probs;$/;"	m	class:RandomPoll	typeref:typename:vector<double>
project	Makefile	/^project: $(OBJECTS) $(HEADERS) | $(BINDIR)$/;"	t
q	README.md	/^# q$/;"	c
quadCosts	include/edge.h	/^    std::vector<int> quadCosts; \/\/ vector with quadratic costs (change to array?)$/;"	m	class:Edge	typeref:typename:std::vector<int>
rb_parent	include/unionFind.h	/^        std::stack<std::pair<int,int>> rb_parent, rb_size;$/;"	m	class:UnionFind	typeref:typename:std::stack<std::pair<int,int>>
rb_size	include/unionFind.h	/^        std::stack<std::pair<int,int>> rb_parent, rb_size;$/;"	m	class:UnionFind	typeref:typename:std::stack<std::pair<int,int>>
removeEdge	include/forest.h	/^        void removeEdge(int i){$/;"	f	class:Forest	typeref:typename:void
removeEdge	include/pathRelinking.h	/^        void removeEdge(std::list<Edge> edges) {$/;"	f	class:PathRelinking	typeref:typename:void
reset	include/unionFind.h	/^        void reset() {$/;"	f	class:UnionFindNRB	typeref:typename:void
result_type	include/fileParser.h	/^        typedef std::size_t result_type;$/;"	t	struct:std::hash	typeref:typename:std::size_t
rollback	include/unionFind.h	/^        void rollback(){$/;"	f	class:UnionFind	typeref:typename:void
rootTree	include/forest.h	/^        void rootTree(int x){$/;"	f	class:Forest	typeref:typename:void
run	include/tabuSearch.h	/^    void run(){$/;"	f	class:TabuSearch	typeref:typename:void
sizes	include/unionFind.h	/^        int *sizes;$/;"	m	class:UnionFind	typeref:typename:int *
sizes	include/unionFind.h	/^        int *sizes;$/;"	m	class:UnionFindNRB	typeref:typename:int *
skew	include/RandomPoll.h	/^    void skew(){$/;"	f	class:RandomPoll	typeref:typename:void
skewFactor	include/RandomPoll.h	/^    double skewFactor;$/;"	m	class:RandomPoll	typeref:typename:double
skewFactorEdges	include/tabuSearch.h	/^    double skewFactorEdges;$/;"	m	class:TabuSearch	typeref:typename:double
skewValue	include/SolutionsPoller.h	/^        double skewValue;$/;"	m	class:SolutionsPoller	typeref:typename:double
solutionsPoller	include/tabuSearch.h	/^    SolutionsPoller solutionsPoller;$/;"	m	class:TabuSearch	typeref:typename:SolutionsPoller
std	include/fileParser.h	/^namespace std$/;"	n
steps	include/backtrack.h	/^        int steps(){$/;"	f	class:BacktrackAlgorithm	typeref:typename:int
steps	include/branchBound.h	/^        int steps(){$/;"	f	class:BBoundAlgorithm	typeref:typename:int
targetTree	include/pathRelinking.h	/^        Tree targetTree;$/;"	m	class:PathRelinking	typeref:typename:Tree
totLoops	include/tabuSearch.h	/^    int totLoops;$/;"	m	class:TabuSearch	typeref:typename:int
u	include/edge.h	/^    int u, v; \/\/ edge endpoints$/;"	m	class:Edge	typeref:typename:int
ufind	include/backtrack.h	/^        UnionFind *ufind;                       \/\/!< Union find$/;"	m	class:BacktrackAlgorithm	typeref:typename:UnionFind *
v	include/edge.h	/^    int u, v; \/\/ edge endpoints$/;"	m	class:Edge	typeref:typename:int
visited	include/branchBound.h	/^    maskType visited, chosen;$/;"	m	struct:State	typeref:typename:maskType
~BBoundAlgorithm	include/branchBound.h	/^        ~BBoundAlgorithm(){$/;"	f	class:BBoundAlgorithm
~BacktrackAlgorithm	include/backtrack.h	/^        ~BacktrackAlgorithm(){$/;"	f	class:BacktrackAlgorithm
~LPLowerBound	include/LPLowerBound.h	/^        ~LPLowerBound(){$/;"	f	class:LPLowerBound
~PBLowerBound	include/PBLowerBound.h	/^        ~PBLowerBound(){$/;"	f	class:PBLowerBound
~Parser	include/fileParser.h	/^        ~Parser(){$/;"	f	class:Parser
~UnionFind	include/unionFind.h	/^        ~UnionFind(){$/;"	f	class:UnionFind
~UnionFindNRB	include/unionFind.h	/^        ~UnionFindNRB(){$/;"	f	class:UnionFindNRB
