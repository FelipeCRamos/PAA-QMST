!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
$(BINDIR)	Makefile	/^$(BINDIR):$/;"	t
$(OBJDIR)	Makefile	/^$(OBJDIR):$/;"	t
$(OBJDIR)/%.o	Makefile	/^$(OBJECTS): $(OBJDIR)\/%.o : $(SRCDIR)\/%.cpp $(HEADERS) | $(OBJDIR)$/;"	t
$(OBJECTS)	Makefile	/^$(OBJECTS): $(OBJDIR)\/%.o : $(SRCDIR)\/%.cpp $(HEADERS) | $(OBJDIR)$/;"	t
Autores	README.md	/^## Autores$/;"	s
BBoundAlgorithm	include/branchBound.h	/^    BBoundAlgorithm(int n, int m, edgeListType &edges, int **costs){$/;"	f	class:BBoundAlgorithm
BBoundAlgorithm	include/branchBound.h	/^class BBoundAlgorithm{$/;"	c
BINDIR	Makefile	/^BINDIR = .\/bin$/;"	m
BacktrackAlgorithm	include/backtrack.h	/^    BacktrackAlgorithm(int n, int m, std::vector<std::pair<int,int>> &edges, int **costs){$/;"	f	class:BacktrackAlgorithm
BacktrackAlgorithm	include/backtrack.h	/^class BacktrackAlgorithm{$/;"	c
C	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
CC	Makefile	/^CC = g++$/;"	m
CLOSEP	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
COMMA	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
DATADIR	Makefile	/^DATADIR = .\/data$/;"	m
DONEF	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
DONEL	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
EDGES	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
ERRORF	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
ERRORL	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
Edges	README.md	/^# Edges$/;"	c
Execução do algoritmo	README.md	/^## Execução do algoritmo$/;"	s
FINAL	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
FileStates	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	g	class:Parser
HEADERS	Makefile	/^HEADERS := $(wildcard $(INCDIR)\/*)$/;"	m
INCDIR	Makefile	/^INCDIR = .\/include$/;"	m
INF	include/defines.h	/^#define INF /;"	d
LPLowerBound	include/LPLowerBound.h	/^        LPLowerBound(int _n, int _m, numType _delta = 30){$/;"	f	class:LPLowerBound
LPLowerBound	include/LPLowerBound.h	/^class LPLowerBound{$/;"	c
ListStates	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	g	class:Parser
M	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
N	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
NBITS	include/defines.h	/^#define NBITS /;"	d
NUM	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
NUMBERS	include/fileParser.h	/^        const std::string NUMBERS = "0123456789";$/;"	m	class:Parser	typeref:typename:const std::string
OBJDIR	Makefile	/^OBJDIR = .\/obj$/;"	m
OBJECTS	Makefile	/^OBJECTS := $(SOURCES:$(SRCDIR)\/%.cpp=$(OBJDIR)\/%.o)$/;"	m
OPENP	include/fileParser.h	/^        enum ListStates { OPENP, NUM, COMMA, CLOSEP, DONEL, ERRORL };$/;"	e	enum:Parser::ListStates
PBLowerBound	include/PBLowerBound.h	/^        PBLowerBound(int _n, int _m){$/;"	f	class:PBLowerBound
PBLowerBound	include/PBLowerBound.h	/^class PBLowerBound{$/;"	c
PROJ_NAME	Makefile	/^PROJ_NAME = agmq$/;"	m
PTAG	src/main.cpp	/^#define PTAG /;"	d	file:
Parser	include/fileParser.h	/^        Parser(std::string _fileName){$/;"	f	class:Parser
Parser	include/fileParser.h	/^class Parser{$/;"	c
Q1	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
Q2	include/fileParser.h	/^        enum FileStates { N, M, EDGES, C, Q1, Q2, FINAL, DONEF, ERRORF };$/;"	e	enum:Parser::FileStates
QMST Problem - NP Hard Project	README.md	/^# QMST Problem - NP Hard Project$/;"	c
RM	Makefile	/^RM = -rm$/;"	m
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SOURCES	Makefile	/^SOURCES := $(wildcard $(SRCDIR)\/*.cpp)$/;"	m
SRCDIR	Makefile	/^SRCDIR = .\/src$/;"	m
State	include/branchBound.h	/^    State(int ne, int c, maskType v, maskType chos, int ac){$/;"	f	struct:State
State	include/branchBound.h	/^struct State{$/;"	s
UnionFind	include/unionFind.h	/^        UnionFind(int n){$/;"	f	class:UnionFind
UnionFind	include/unionFind.h	/^class UnionFind{$/;"	c
UnionFindNRB	include/unionFind.h	/^        UnionFindNRB(int n){$/;"	f	class:UnionFindNRB
UnionFindNRB	include/unionFind.h	/^class UnionFindNRB{$/;"	c
_ARG_PARSER_H_	include/argParser.h	/^#define _ARG_PARSER_H_$/;"	d
_BACKTRACK_H_	include/backtrack.h	/^#define _BACKTRACK_H_$/;"	d
_BBOUND_H_	include/branchBound.h	/^#define _BBOUND_H_$/;"	d
_FILE_PARSER_H_	include/fileParser.h	/^#define _FILE_PARSER_H_$/;"	d
_HELP_FN_H_	include/helpFn.h	/^#define _HELP_FN_H_$/;"	d
_PB_LOWER_BOUND_H_	include/PBLowerBound.h	/^#define _PB_LOWER_BOUND_H_$/;"	d
_UNION_FIND_H_	include/unionFind.h	/^#define _UNION_FIND_H_$/;"	d
_backtrack	include/backtrack.h	/^    int _backtrack(int i, int cost){$/;"	f	class:BacktrackAlgorithm	typeref:typename:int
_bbound	include/branchBound.h	/^    int _bbound(){$/;"	f	class:BBoundAlgorithm	typeref:typename:int
_costs	include/backtrack.h	/^    int **_costs; \/\/ matriz de custos$/;"	m	class:BacktrackAlgorithm	typeref:typename:int **
_costs	include/branchBound.h	/^    int **_costs; \/\/ matriz de custos$/;"	m	class:BBoundAlgorithm	typeref:typename:int **
_defines_h_	include/defines.h	/^#define _defines_h_$/;"	d
_edges	include/backtrack.h	/^    std::vector<std::pair<int,int>> _edges; \/\/ lista com todas as arestas$/;"	m	class:BacktrackAlgorithm	typeref:typename:std::vector<std::pair<int,int>>
_edges	include/branchBound.h	/^    edgeListType _edges; \/\/ lista com todas as arestas$/;"	m	class:BBoundAlgorithm	typeref:typename:edgeListType
_m	include/backtrack.h	/^    int _m, _n; \/\/ qntd de arestas e de nos$/;"	m	class:BacktrackAlgorithm	typeref:typename:int
_m	include/branchBound.h	/^    int _m, _n; \/\/ qntd de arestas e de nos$/;"	m	class:BBoundAlgorithm	typeref:typename:int
_n	include/backtrack.h	/^    int _m, _n; \/\/ qntd de arestas e de nos$/;"	m	class:BacktrackAlgorithm	typeref:typename:int
_n	include/branchBound.h	/^    int _m, _n; \/\/ qntd de arestas e de nos$/;"	m	class:BBoundAlgorithm	typeref:typename:int
_n	include/unionFind.h	/^        int _n;$/;"	m	class:UnionFind	typeref:typename:int
_n	include/unionFind.h	/^        int _n;$/;"	m	class:UnionFindNRB	typeref:typename:int
all	Makefile	/^all: project$/;"	t
allocateCosts	include/fileParser.h	/^        void allocateCosts(){$/;"	f	class:Parser	typeref:typename:void
alreadyChosen	include/branchBound.h	/^    int nextEdge, cost, alreadyChosen;$/;"	m	struct:State	typeref:typename:int
argument_type	include/fileParser.h	/^        typedef pair<int,int> argument_type;$/;"	t	struct:std::hash	typeref:typename:pair<int,int>
autolabel	plot.py	/^def autolabel(rects):$/;"	f
backTrackEdgeNumbers	plot.py	/^backTrackEdgeNumbers = [ x[1] for x in backtrackSetPlot ]$/;"	v
backTrackTimes	plot.py	/^backTrackTimes = [ x[0] for x in backtrackSetPlot ]$/;"	v
backtrack	include/backtrack.h	/^    int backtrack(){$/;"	f	class:BacktrackAlgorithm	typeref:typename:int
backtrackSetPlot	plot.py	/^backtrackSetPlot = [ (int(infos[file]['time']), file) for file in infos ]$/;"	v
bbound	include/branchBound.h	/^    int bbound(){$/;"	f	class:BBoundAlgorithm	typeref:typename:int
branchAndBoundEdgeNumbers	plot.py	/^branchAndBoundEdgeNumbers = [ x[1] for x in branchAndBoundSetPlot ]$/;"	v
branchAndBoundSetPlot	plot.py	/^branchAndBoundSetPlot = [ (int(infos[file]['time']) + 40000, file) for file in infos ]$/;"	v
branchAndBoundTimes	plot.py	/^branchAndBoundTimes = [ x[0] for x in branchAndBoundSetPlot ]$/;"	v
c	README.md	/^# c$/;"	c
chosen	include/branchBound.h	/^    maskType visited, chosen;$/;"	m	struct:State	typeref:typename:maskType
clean	Makefile	/^clean: clean_proj$/;"	t
clean_proj	Makefile	/^clean_proj:$/;"	t
cmp	include/PBLowerBound.h	/^bool cmp(std::pair<numType,int> &a, std::pair<numType,int> &b){$/;"	f	typeref:typename:bool
command	plot.py	/^    command = ".\/agmq tests\/10-30\/{} >> log.txt".format(file)$/;"	v
command_list	plot.py	/^command_list = list()$/;"	v
computeLB	include/branchBound.h	/^    void computeLB(int n, int m, edgeListType &edges, int **costs){$/;"	f	struct:State	typeref:typename:void
cost	include/branchBound.h	/^    int nextEdge, cost, alreadyChosen;$/;"	m	struct:State	typeref:typename:int
costs	include/fileParser.h	/^        int **costs;$/;"	m	class:Parser	typeref:typename:int **
counter	include/backtrack.h	/^    long int counter = 0;$/;"	m	class:BacktrackAlgorithm	typeref:typename:long int
counter	include/branchBound.h	/^    long int counter = 0;$/;"	m	class:BBoundAlgorithm	typeref:typename:long int
debug	src/main.cpp	/^#define debug /;"	d	file:
delta	include/LPLowerBound.h	/^        numType delta;$/;"	m	class:LPLowerBound	typeref:typename:numType
dicEntry	plot.py	/^        dicEntry = dict()$/;"	v
done	include/backtrack.h	/^    bool done = false;$/;"	m	class:BacktrackAlgorithm	typeref:typename:bool
edgeID	include/fileParser.h	/^        std::unordered_map<std::pair<int,int>, int> edgeID;$/;"	m	class:Parser	typeref:typename:std::unordered_map<std::pair<int,int>,int>
edgeListType	include/LPLowerBound.h	/^#define edgeListType /;"	d
edgeListType	include/PBLowerBound.h	/^#define edgeListType /;"	d
edgeListType	include/branchBound.h	/^#define edgeListType /;"	d
edges	include/fileParser.h	/^        std::vector<std::pair<int,int>> edges;$/;"	m	class:Parser	typeref:typename:std::vector<std::pair<int,int>>
entry	plot.py	/^        entry = logEntry.split(';')$/;"	v
eof	README.md	/^# eof$/;"	c
error	include/helpFn.h	/^std::string error(std::string errorName, std::string helpText = "") {$/;"	f	typeref:typename:std::string
fCosts	include/LPLowerBound.h	/^        numType *fCosts;$/;"	m	class:LPLowerBound	typeref:typename:numType *
f_i	include/PBLowerBound.h	/^        numType f_i(edgeListType &edges,  maskType visited, maskType chosen, \\$/;"	f	class:PBLowerBound	typeref:typename:numType
fileName	include/fileParser.h	/^        std::string fileName;$/;"	m	class:Parser	typeref:typename:std::string
file_list	plot.py	/^file_list = sorted([str(filename) for filename in os.listdir("tests\/10-30\/") if isSmallerThan(/;"	v
find	include/unionFind.h	/^        int find(int current){$/;"	f	class:UnionFind	typeref:typename:int
find	include/unionFind.h	/^        int find(int current){$/;"	f	class:UnionFindNRB	typeref:typename:int
getCosts	include/fileParser.h	/^        int** getCosts(){ return costs; }$/;"	f	class:Parser	typeref:typename:int **
getEdges	include/fileParser.h	/^        std::vector<std::pair<int,int>> getEdges(){ return edges; }$/;"	f	class:Parser	typeref:typename:std::vector<std::pair<int,int>>
getM	include/fileParser.h	/^        int getM(){ return m; }$/;"	f	class:Parser	typeref:typename:int
getN	include/fileParser.h	/^        int getN(){ return n; }$/;"	f	class:Parser	typeref:typename:int
hash	include/fileParser.h	/^    template<> struct hash<pair<int,int>>$/;"	s	namespace:std
infos	plot.py	/^infos = dict()$/;"	v
isSmallerThan	plot.py	/^def isSmallerThan(string):$/;"	f
join	include/unionFind.h	/^        void join(int a, int b){$/;"	f	class:UnionFind	typeref:typename:void
join	include/unionFind.h	/^        void join(int a, int b){$/;"	f	class:UnionFindNRB	typeref:typename:void
kruskal	include/PBLowerBound.h	/^        int kruskal(kruskalListType &kruskalList, edgeListType &edges, \\$/;"	f	class:PBLowerBound	typeref:typename:int
kruskalListType	include/PBLowerBound.h	/^#define kruskalListType /;"	d
levelingProcedure	include/LPLowerBound.h	/^        numType levelingProcedure(edgeListType edges, maskType &visited, maskType &chosen, \\$/;"	f	class:LPLowerBound	typeref:typename:numType
logFile	plot.py	/^    logFile = logFile.read().split('\\n')$/;"	v
lowerBound	include/branchBound.h	/^    numType lowerBound;$/;"	m	struct:State	typeref:typename:numType
m	README.md	/^# m$/;"	c
m	include/LPLowerBound.h	/^        int n, m;$/;"	m	class:LPLowerBound	typeref:typename:int
m	include/PBLowerBound.h	/^        int n, m;$/;"	m	class:PBLowerBound	typeref:typename:int
m	include/fileParser.h	/^        int n, m;$/;"	m	class:Parser	typeref:typename:int
main	src/main.cpp	/^int main(int argc, char **argv){$/;"	f	typeref:typename:int
makeTests	plot.py	/^makeTests = True$/;"	v
maskType	include/LPLowerBound.h	/^#define maskType /;"	d
maskType	include/PBLowerBound.h	/^#define maskType /;"	d
maskType	include/branchBound.h	/^#define maskType /;"	d
n	README.md	/^# n$/;"	c
n	include/LPLowerBound.h	/^        int n, m;$/;"	m	class:LPLowerBound	typeref:typename:int
n	include/PBLowerBound.h	/^        int n, m;$/;"	m	class:PBLowerBound	typeref:typename:int
n	include/fileParser.h	/^        int n, m;$/;"	m	class:Parser	typeref:typename:int
nextEdge	include/branchBound.h	/^    int nextEdge, cost, alreadyChosen;$/;"	m	struct:State	typeref:typename:int
np	plot.py	/^import numpy as np$/;"	I
numType	include/LPLowerBound.h	/^#define numType /;"	d
numType	include/PBLowerBound.h	/^#define numType /;"	d
numType	include/branchBound.h	/^#define numType /;"	d
operator ()	include/fileParser.h	/^        result_type operator()(argument_type const& s) const noexcept$/;"	f	struct:std::hash	typeref:typename:result_type
operator <	include/branchBound.h	/^bool operator <(const State & a, const State & b){$/;"	f	typeref:typename:bool
parents	include/unionFind.h	/^        int *parents;$/;"	m	class:UnionFind	typeref:typename:int *
parents	include/unionFind.h	/^        int *parents;$/;"	m	class:UnionFindNRB	typeref:typename:int *
parse	include/fileParser.h	/^        bool parse(){$/;"	f	class:Parser	typeref:typename:bool
parseFilename	include/argParser.h	/^std::string parseFilename(int argc, char **argv) {$/;"	f	typeref:typename:std::string
parseList	include/fileParser.h	/^        bool parseList(std::string s, std::string dels, int numberElements, int *array){$/;"	f	class:Parser	typeref:typename:bool
parseParam	include/argParser.h	/^std::pair<std::string, std::string> parseParam(std::string rawParam) {$/;"	f	typeref:typename:std::pair<std::string,std::string>
pb	include/PBLowerBound.h	/^        numType pb(edgeListType edges,  maskType &visited,  maskType &chosen, \\$/;"	f	class:PBLowerBound	typeref:typename:numType
pblb	include/LPLowerBound.h	/^        PBLowerBound* pblb;$/;"	m	class:LPLowerBound	typeref:typename:PBLowerBound *
piParameters	include/LPLowerBound.h	/^        numType *piParameters;$/;"	m	class:LPLowerBound	typeref:typename:numType *
placed	include/backtrack.h	/^    std::vector<int> placed; \/\/ lista de arestas sendo utilizadas no backtrack$/;"	m	class:BacktrackAlgorithm	typeref:typename:std::vector<int>
plt	plot.py	/^import matplotlib.pyplot as plt$/;"	I
prepareUFind	include/branchBound.h	/^    void prepareUFind(State & state, UnionFindNRB *ufind){$/;"	f	class:BBoundAlgorithm	typeref:typename:void
project	Makefile	/^project: $(OBJECTS) $(HEADERS) | $(BINDIR)$/;"	t
q	README.md	/^# q$/;"	c
rb_parent	include/unionFind.h	/^        std::stack<std::pair<int,int>> rb_parent, rb_size;$/;"	m	class:UnionFind	typeref:typename:std::stack<std::pair<int,int>>
rb_size	include/unionFind.h	/^        std::stack<std::pair<int,int>> rb_parent, rb_size;$/;"	m	class:UnionFind	typeref:typename:std::stack<std::pair<int,int>>
result_type	include/fileParser.h	/^        typedef std::size_t result_type;$/;"	t	struct:std::hash	typeref:typename:std::size_t
rollback	include/unionFind.h	/^        void rollback(){$/;"	f	class:UnionFind	typeref:typename:void
sizes	include/unionFind.h	/^        int *sizes;$/;"	m	class:UnionFind	typeref:typename:int *
sizes	include/unionFind.h	/^        int *sizes;$/;"	m	class:UnionFindNRB	typeref:typename:int *
std	include/fileParser.h	/^namespace std$/;"	n
steps	include/backtrack.h	/^    int steps(){$/;"	f	class:BacktrackAlgorithm	typeref:typename:int
steps	include/branchBound.h	/^    int steps(){$/;"	f	class:BBoundAlgorithm	typeref:typename:int
ufind	include/backtrack.h	/^    UnionFind *ufind; \/\/ estrutura union find$/;"	m	class:BacktrackAlgorithm	typeref:typename:UnionFind *
visited	include/branchBound.h	/^    maskType visited, chosen;$/;"	m	struct:State	typeref:typename:maskType
~BBoundAlgorithm	include/branchBound.h	/^    ~BBoundAlgorithm(){}$/;"	f	class:BBoundAlgorithm
~BacktrackAlgorithm	include/backtrack.h	/^    ~BacktrackAlgorithm(){$/;"	f	class:BacktrackAlgorithm
~LPLowerBound	include/LPLowerBound.h	/^        ~LPLowerBound(){$/;"	f	class:LPLowerBound
~PBLowerBound	include/PBLowerBound.h	/^        ~PBLowerBound(){$/;"	f	class:PBLowerBound
~Parser	include/fileParser.h	/^        ~Parser(){$/;"	f	class:Parser
~UnionFind	include/unionFind.h	/^        ~UnionFind(){$/;"	f	class:UnionFind
~UnionFindNRB	include/unionFind.h	/^        ~UnionFindNRB(){$/;"	f	class:UnionFindNRB
